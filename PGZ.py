import math  # Импорт библеотеки математических инструментов


def sk(w):  # Функция для выбора СК
    if w == 'СК-42':
        a, alfa = 6378245, 1 / 298.3
    elif w == 'WGS-84':
        a, alfa = 6378137, 1 / 298.257223563
    elif w == 'ПЗ-90.11':
        a, alfa = 6378136, 1 / 298.25784
    elif w == 'ГСК-2011':
        a, alfa = 6378136.5, 1 / 298.2564151
    else:
        print('Название введено некорректно')
        raise SystemExit  # обработка досрочного выхода из программы
    return a, alfa  # Возвращает значение большой полуоси эллипсойда и полярного сжатия


# Ввод пользователем нужной СК
q = input('Введите название геодезической системы координат (СК-42, WGS-84, ПЗ 90.11 или ГСК-2011): ')
a, alfa = sk(q)  # Введённая СК подаётся на вход функции для выбора этой СК
# Организация ввода исходных эллипсоидальных геодезических координат т.1
b1 = [int(input('Введети градусы B1: ')), int(input('Введети минуты B1: ')), float(input('Введети секунды B1: '))]
l1 = [int(input('Введети градусы L1: ')), int(input('Введети минуты L1: ')), float(input('Введети секунды L1: '))]
h1 = float(input('Введите H1 в м: '))


def rad(x):  # Функция для преобразования в радианы с учётом знака введённых градусов
    y = math.radians(abs(x[0]) + (abs(x[1]) / 60) + (abs(x[2]) / 3600))
    if x[0] < 0:
        y = (-1)*y
    return y  # Возвращает угол в радианах


b1rad = rad(b1)  # Преобразование геодезической широты т.1 в радианы
# Проверка правильности введённой широты т.1
if abs(b1rad) > math.pi / 2 or b1rad == 0 or abs(b1[1]) >= 60 or abs(b1[2]) >= 60:
    print('B1 введено некорректно')
    raise SystemExit  # обработка досрочного выхода из программы
l1rad = rad(l1)  # Преобразование геодезической долготы т.1 в радианы
# Проверка правильности введённой долготы т.1
if abs(l1rad) > math.pi or l1rad == 0 or abs(l1[1]) >= 60 or abs(l1[2]) >= 60:
    print("L1 введено некорректно")
    raise SystemExit  # обработка досрочного выхода из программы

# Организация ввода полярных пространственных сферических координат т.2 относ. т.1
a12 = [int(input('Введети градусы A12: ')), int(input('Введети минуты A12: ')), float(input('Введети секунды A12: '))]
z12 = [int(input('Введети градусы Z12: ')), int(input('Введети минуты Z12: ')), float(input('Введети секунды Z12: '))]
s12 = float(input('Введите S12 в м: '))
a12rad = rad(a12)  # Преобразование геодезического азимута в радианы
# Проверка правильности введённого азимута
if abs(a12rad) > 2*math.pi or a12rad == 0 or abs(a12[1]) >= 60 or abs(a12[2]) >= 60:
    print("A12 введено некорректно")
    raise SystemExit  # обработка досрочного выхода из программы
z12rad = rad(z12)  # Преобразование зенитного расстрония в радианы
# Проверка правильности введённого зенитного расстояния
if abs(z12rad) > math.pi or z12rad == 0 or abs(z12[1]) >= 60 or abs(z12[2]) >= 60:
    print("Z12 введено некорректно")
    raise SystemExit  # обработка досрочного выхода из программы

e = 2*alfa - alfa**2  # Вычисление квадртата первого эксцентриситета
n1 = a / (1 - e*math.sin(b1rad)**2)**0.5  # Вычисление радиуса кривизны первого вертикала в т. 1
# Преобразование эллипсоидальных геодезических координат т.1 в пространственные геоцентрические
# экваториальные прямоугольные координаты
xyz1 = [(n1 + h1)*math.cos(b1rad)*math.cos(l1rad), (n1 + h1)*math.cos(b1rad)*math.sin(l1rad),
        (n1 + h1 - e*n1)*math.sin(b1rad)]
# Преобразование пространственных горизонтных сферических координат т.2 относ. т.1 в пространственные топоцентрические
# горизонтные прямоугольные координаты
xyz12 = [s12*math.cos(a12rad)*math.sin(z12rad), s12*math.sin(a12rad)*math.sin(z12rad), s12*math.cos(z12rad)]
# Формирование матрицы поворота с помощью вложенныех списков
A = [[-math.sin(b1rad)*math.cos(l1rad), -math.sin(l1rad), math.cos(b1rad)*math.cos(l1rad)],
     [-math.sin(b1rad)*math.sin(l1rad), math.cos(l1rad), math.cos(b1rad)*math.sin(l1rad)],
     [math.cos(b1rad), 0, math.sin(b1rad)]]
# Вычисление пространственных геоцентрических экваториальных прямоугольных координат т.2
xyz2 = [0, 0, 0]
i = 0
while i != 3:  # Цикл для формирования списка, содержащего прямоугольные координаты т.2
    xyz2[i] = xyz1[i] + (A[i][0]*xyz12[0] + A[i][1]*xyz12[1] + A[i][2]*xyz12[2])
    i += 1
l2 = math.atan(xyz2[1] / xyz2[0])  # Вычисление геодезической долготы т.2
d12 = (xyz2[0]**2 + xyz2[1]**2)**0.5  # Вычисление экваториального расстояния до т.2
# Вычисление первого члена итерационной формулы, необходимого для нахождения геодезической широты т.2
e0 = e*a / (d12**2 + xyz2[2]**2 / (1 - e))**0.5


def iter(e0, e, a, d12, xyz2):  # Функция для выполения итерационного процесса нахождения параметра ek
    d = None
    k = 1
    n = [e0]
    while d != 0:  # Проверка сходимости итерационного процесса
        n.append(e*a / (d12**2 + (1 - e)*xyz2[2]**2 / (1 - n[k - 1])**2)**0.5)
        d = abs(n[k]) - abs(n[k - 1])
        k += 1
    ek = n[-1]
    return ek  # Возвращает значение параметра последней итерации


ek = iter(e0, e, a, d12, xyz2)  # Вычисление последнего члена итерационной формулы
# Вычисление геодезической широты т.2
if d12 < xyz2[2]:
    b2 = math.atan(xyz2[2] / (d12*(1 - ek)))
else:
    b2 = math.atan(d12*(1 - ek) / xyz2[2])
n2 = a / (1 - e*math.sin(b2)**2)**0.5  # Вычисление радиуса кривизны первого вертикала в т.2
# Вычисление высоты т.2
if b2 > math.pi / 4:
    h2 = d12 / math.cos(b2) - n2
else:
    h2 = xyz2[2] / math.sin(b2) - n2 - e*n2

# Контроль правильности вычислений координат т.2 и вывод сообщения на экран
dcontrol = (n2 + h2)*math.cos(b2)
if round(abs(d12), 3) == round(abs(dcontrol), 3):
    print('Контроль выполнен')
else:
    print('Контроль не выполнен')


def count(x):  # Функция, которая возвращает кол-во цифр в числе после запятой
    s = str(x)
    f = s.find('.')
    t = len(s) - (f + 1)
    ff = s.find('.0')
    if t > 1 and f != -1:  # обработка варианта 0.01
        return t
    elif ff == (-1):  # обработка варианта 0.1
        return t
    else:
        return 0  # вариант 0.0


# Определение точности введённых исходных данных
tb1 = count_ust(b1[2])
th1 = count_ust(h1)


def deg(x, t):  # Функция для преобразование радианов в градусы, минуты и секунды с необходимой точностью
    y = [int(math.degrees(abs(x))), int((math.degrees(abs(x)) - int(math.degrees(abs(x))))*60),
         round((math.degrees(abs(x)) - int(math.degrees(abs(x))) - int((math.degrees(abs(x))
                                                                       - int(math.degrees(abs(x))))*60)/60)*3600, t)]
    return y  # Возвращает угол в градусах, минутах и секундах


b2deg = deg(b2, tb1)  # Преобразование геодезической широты B2 в угловую меру с точностью исх. данных
l2deg = deg(l2, tb1)  # Преобразование геодезической долготы L2 в угловую меру с точностью исх. данных
h2r = round(h2, th1)  # Геодезическое округление высоты H2 до точности исх. данных

# Вывод результатов на экран
print(' B2 =', b2deg[0], b2deg[1], b2deg[2], '\n', 'L2 =', l2deg[0], l2deg[1], l2deg[2], '\n', 'H2 =', h2r, 'м')
